data$Area
unique(data$Area)
summarY(data$Area)
summary(data$Area)
source('~/R/TEST.R')
install.packages("ElemStatLearn")
source('~/R/TEST.R')
source('~/R/TEST.R')
missClass = function(values,prediction){sum(((prediction > 0.5)*1) != values)/length(values)}
missClass(testSA, prediction)
missClass(trainSA, modfit$predict)
modfit$predict
names(modfit)
modfit$pred
modfit$results
modfit$trainingData
trainSA
missClass(trainSA$chd, modfit$trainingData$.outcome)
modfit$trainingData
modfit$trainingData.outcome
modfit$trainingData$.outcome
missClass(trainSA$chd, modfit$trainingData$.outcome)
names(modfit)
modfit
names(modfit)
modfit(dots)
modfit$dots
modfit$metric
modfit$control
names(modfit)
modfit$finalModel
missClass(testSA$chd, prediction)
summary(modfit)
table(modfit)
?train
modfit$bestTune
modfit$results
modfit$trainingData
prediction2 = predict(modfit, newdata=trainSA)
missclass(trainSA$chd, prediction2)
missClass(trainSA$chd, prediction2)
library(ElemStatLearn)
data(vowel.train)
data(vowel.test)
vowel.test
vowel.train
source('~/R/TEST.R')
varImp(modfit)
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
gc()
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
par()
par("pch")
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
?mtcars
?shuttle
library("MASS", lib.loc="C:/Program Files/R/R-3.1.0/library")
?shuttle
source('~/R/TEST.R')
shuttle
as.factor(use)
source('~/R/TEST.R')
source('~/R/TEST.R')
?family
logit
source('~/R/TEST.R')
summary(modfit)
ls(modfit)
modfit$coefficients
source('~/R/TEST.R')
odds.ratio(modfit$coefficients[1], modfit$coefficients[2], wind)
wind
as.integer(wind)
as.integer(wind) - 1
odds.ratio(modfit$coefficients[1], modfit$coefficients[2], as.integer(wind) - 1)
odds.ratio(modfit$coefficients[1], modfit$coefficients[2], ifelse(wind == head, 1, 0))
ifelse(wind == head, 1, 0)
ifelse(wind == "head", 1, 0)
odds.ratio(modfit$coefficients[1], modfit$coefficients[2], ifelse(wind == "head", 1, 0))
modfit$coefficients
exp(modfit$coefficients)
source('~/R/TEST.R')
wind
as.integer(wind)
ifelse(wind == "head", 1, 0)
source('~/R/TEST.R')
modfit$coefficients
odds(modfit$coefficients[1], modfit$coefficients[2], 1)
odds(modfit$coefficients[1], modfit$coefficients[2], 0)
odds(modfit$coefficients[1], modfit$coefficients[2], c(0,1))
odds(modfit$coefficients[1], modfit$coefficients[2], c(tail=0,head=1))
odds = odds(modfit$coefficients[1], modfit$coefficients[2], c(tail=0,head=1))
odds["head"]
odds["head"] / (1 - odds["head"])
odds["head"] / odds["tail"]
exp(modfit$coefficients[1])
exp(modfit$coefficients[2])
modfit$coefficients
odds = odds(modfit$coefficients[1], modfit$coefficients[2], wind)
source('~/R/TEST.R')
odds = odds(modfit$coefficients[1], modfit$coefficients[2], wind)
odds
odds = odds(modfit$coefficients[1], modfit$coefficients[2], as.integer(wind))
odds = odds(modfit$coefficients[1], modfit$coefficients[2], as.integer(wind))
rm(odds)
source('~/R/TEST.R')
probs = odds(modfit$coefficients[1], modfit$coefficients[2], as.integer(wind))
probs
as.integer(wind)
wind
probs = odds(modfit$coefficients[1], modfit$coefficients[2], c("head"=1, "tail"=2))
probs
probs["head"] / probs["tail"]
probs["head"] / (1 - probs["head"])
source('~/R/TEST.R')
source('~/R/TEST.R')
modfit$coefficients
wind
as.integer(wind)
probs = probability(modfit$coefficients[1], modfit$coefficients[2], c(tail=2, head=1))
probs
probs["head"] / probs["tail"]
probs["head"] / (1 + probs["head"])
probs["head"] / (1 - probs["head"])
probs["tail"] / probs["head"]
exp(modfit$coefficients)
probs
probs / (1-probs)
modfit$coefficients
modfit$coefficients * -1
coefs = modfit$coefficients * -1
coefsa
coefs
probs = probability(coefs[1], coefs[2], c(head=1, tail=2))
probs
wind
as.integer(wind)
probs["head"] / probs["tail"]
probs["tail"] / probs["head"]
source('~/R/TEST.R')
modfit$coefficients
exp(modfit$coefficients)
source('~/R/TEST.R')
source('~/R/TEST.R')
magn
source('~/R/TEST.R')
exp(modfit$coefficients[2])
source('~/R/TEST.R')
exp(modfit$coefficients[2])
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
use
as.integer(use)
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
InsectSprays
data=InsectSprays
names(data)
source('~/R/TEST.R')
exp(.05588)
1.057471*2.67415
2.827836-2.67415
source('~/R/TEST.R')
exp(.05588)
exp(-.05588)
as.factor(spray)
as.integer(spray)
as.factor(as.integer(spray))
source('~/R/TEST.R')
log(10)
as.factor(as.integer(spray)) + log(10)
as.factor(as.integer(spray) + log(10))
as.integer(spray) + log(10)
source('~/R/TEST.R')
source('~/R/TEST.R')
x
y
plot(y ~ x)
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
y[y <= 0]
y
x[x <= 0]
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
lm1
ls(lm1)
summary(lm1)
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
summary(lm1)
ls(lm1)
lm1$model
lm1$call
lm1$assign
abline(lm(I(y + lm1$coefficients[1]) ~ x, subset=x[x <= 0]))
abline(lm(I(y - lm1$coefficients[1]) ~ x, subset=x[x <= 0]))
source('~/R/TEST.R')
abline(v=0)
abline(h=0)
lm1$fitted.values
lm1$model
source('~/R/TEST.R')
lm2$fitted.values
lm2
abline(lm2)
lm2
ls(lm2)
lm2$model
lm1$model
lm1$fitted.values
lm2$fitted.values
source('~/R/TEST.R')
yhat
yhat[3] / 5
1.013*5
source('~/R/TEST.R')
source('~/R/TEST.R')
vowel.test
vowel.train
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
table(gbmpredict, vowel.test$y)
summary(gbmpredict)
vowel.test[vowel.test$y != gbmpredict, "y"]
vowel.test$y
length(vowel.test[vowel.test$y != gbmpredict, "y"])
length(vowel.test[vowel.test$y == gbmpredict, "y"])
237/(237+225)
length(vowel.test[vowel.test$y == rfpredict, "y"])
length(vowel.test[vowel.test$y != rfpredict, "y"])
281/(281+181)
length(vowel.test[vowel.test$y == rfpredict == gbmpredict, "y"])
length(vowel.test[vowel.test$y == rfpredict & rfpredict == gbmpredict, "y"])
length(vowel.test[vowel.test$y != rfpredict & rfpredict == gbmpredict, "y"])
205/(205+112)
source('~/R/TEST.R')
rm(vowel.train)
rm(vowel.test)
gc()
source('~/R/TEST.R')
trainControl()
source('~/R/TEST.R')
predictions = data.frame(predrf, predgbm, predlda, testing$diagnosis)
sum((predictions[,1] == predictions[,4]) ^ 2)
sum((predictions[,2] == predictions[,4]) ^ 2)
sum((predictions[,3] == predictions[,4]) ^ 2)
predictions[,3] == predictions[,4]
(predictions[,3] == predictions[,4]) * 1
((predictions[,3] == predictions[,4]) * 1) / nrow(predictions)
(predictions[,3] == predictions[,4]) * 1
sum((predictions[,3] == predictions[,4]) * 1)
sum((predictions[,3] == predictions[,4]) * 1) / nrow(predictions)
sum((predictions[,1] == predictions[,4]) * 1) / nrow(predictions)
sum((predictions[,2] == predictions[,4]) * 1) / nrow(predictions)
sum((predictions[,3] == predictions[,4]) * 1) / nrow(predictions)
sum(predictions[,1] == predictions[,4])
accuracies = with(predictions, c(rf=accuracy(predrf), gbm=accuracy(predgbm), lda=accuracy(predlda)))
accuracy = function(x) {
sum(x == predictions[,4]) / nrow(predictions)
}
accuracies = with(predictions, c(rf=accuracy(predrf), gbm=accuracy(predgbm), lda=accuracy(predlda)))
accuracies
# Create stacked model using Random Forests
message("Training model...")
begin = Sys.time()
stackedmod = train(predictions[,4] ~ ., method="rf")
end = Sys.time()
message(sprintf("Time to fit model, with %d cores: %d minutes %d seconds.",
detectCores() - ignorecores,
floor(as.numeric(end-begin, units="mins")),
floor(as.numeric(end-begin, units="secs")) %% 60))
# Create stacked model using Random Forests
message("Training model...")
begin = Sys.time()
stackedmod = train(predictions[,4] ~ ., data=predictions, method="rf")
end = Sys.time()
message(sprintf("Time to fit model, with %d cores: %d minutes %d seconds.",
detectCores() - ignorecores,
floor(as.numeric(end-begin, units="mins")),
floor(as.numeric(end-begin, units="secs")) %% 60))
# Calculate accuracies of predictions
accuracies = with(predictions, c(rf=accuracy(predrf), gbm=accuracy(predgbm), lda=accuracy(predlda), stacked=accuracy(stackedpred)))
# Create predictions from stacked model
stackedpred = predict(stackedmod, newdata=testing$diagnosis)
source('~/R/TEST.R')
testing$diagnosis
stackedpred = predict(stackedmod, newdata=testing$diagnosis)
stackedmod
stackedpred = predict(stackedmod, newdata=testing)
stackedpred
source('~/R/TEST.R')
accuracies
set.seed(3523)
library(AppliedPredictiveModeling)
data(concrete)
inTrain = createDataPartition(concrete$CompressiveStrength, p = 3/4)[[1]]
training = concrete[ inTrain,]
testing = concrete[-inTrain,]
set.seed(233)
names(getModelInfo())
getModelInfo()
getModelInfo("lasso")
?plot.enet
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
source('~/R/TEST.R')
lassomod
?plot.enet
plot.enet(lassomod)
str(lassomod)
?plot.enet
plot(lassomod, data=training)
plot.enet(lassomod, data=training)
plot.enet(lassomod, xvar="penalty", use.color=T)
plot.enet(lassomod$finalmodel, xvar="penalty", use.color=T)
plot.enet(lassomod$finalModel, xvar="penalty", use.color=T)
lassomod$finalModel
install.packages("forecast")
library(forecast)
?bats
source('~/R/TEST.R')
source('~/R/TEST.R')
?ts
?forecast
source('~/R/TEST.R')
tstest = ts(testing$visitsTumblr)
forecast = forecast(bats, tstest)
forecast = forecast(bats, newdata=tstest)
forecast
tstest
testing
nrow(tstest)
str(tstest)
length(tstest)
length(forecasr)
length(forecast)
length(tstrain)
training$visitsTumblr
tstrain
tstest
training
forecast = forecast(bats, newdata=testing)
forecast
testing
forecast = forecast(bats, newdata=testing, h=nrow(testing))
forecast
forecast = forecast(bats, newdata=testing, h=nrow(testing))$Forecast
forecast
forecast = forecast(bats, newdata=testing, h=nrow(testing))
forecast
ls(forecast)
names(forecast)
forcast$x
forecast$x
forecast$model
forecast$fitted
forecast
?ets
forecast = forecast(bats, newdata=testing)
forecast
forecast = forecast(bats, newdata=testing, h=nrow(testing))
forecast$"Point Forecast"
str(forecast)
forecast$mean
testign
testing
testing$VisitsTumblr
testing$visitsTumblr
names(forecast)
forecast$mean
forecast$upper
forecast$upper[,2]
testing$visitsTumblr < forecast$upper[,2]
forecast$lower
testing$visitsTumblr < forecast$upper[,2] & testing$visitsTumblr > forecast$lower[,2]
sum(testing$visitsTumblr < forecast$upper[,2] & testing$visitsTumblr > forecast$lower[,2])
sum(testing$visitsTumblr < forecast$upper[,2] & testing$visitsTumblr > forecast$lower[,2]) / length(testing$visitsTumblr)
library("e1071", lib.loc="~/R/win-library/3.1")
detach("package:e1071", unload=TRUE)
library("e1071", lib.loc="~/R/win-library/3.1")
source('~/R/TEST.R')
help(e1071)
help("e1071")
??e1071
?svm
source('~/R/TEST.R')
set.seed(325)
svm = svm(CompressiveStrength ~ ., data=training)
predictions = predict(svm, newdata=testing)
prediction
predictions
?rmse
class(predictions)
testing
testing$CompressiveStrength
testing$CompressiveStrength - predictions
mean((testing$CompressiveStrength - predictions) ^ 2)
sqrt(mean((testing$CompressiveStrength - predictions) ^ 2))
library(caret)
library(gbm)
set.seed(3433)
library(AppliedPredictiveModeling)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
set.seed(62433)
source('~/R/TEST.R')
accuracies
stacked[red]
stackedpred
testing$diagnosis
source('~/R/TEST.R')
source('~/R/TEST.R')
warnings()
testing$diagnosis
testing$diagnosis * 1
as.integer(testing$diagnosis)
source('~/R/TEST.R')
accuracy(predrf)
predrf
predrf == testing$diagnosis
sum(predrf == testing$diagnosis)
source('~/R/TEST.R')
accuracies
predrf
predrf == testing$diagnosis
sum(predrf == testing$diagnosis)
sum(predrf == testing$diagnosis) / length(testing$diagnosis)
source('~/R/TEST.R')
createDataPartition(training$diagnosis, p = 3/4)[[1]]
source('~/R/TEST.R')
source('~/R/TEST.R')
exists("rf")
exists("rf", inherits=F)
!exists("rf", inherits=F)
source('~/R/TEST.R')
warnings()
predrf
checking$diagnosis
accuracies
training$diagnosis
checking$diagnosis
testing$diagnosis
createDataPartition(adData$diagnosis, p = 3/4)[[1]]
createDataPartition(adData$diagnosis, p = 3/4)
createDataPartition(training$diagnosis, p = 3/4)[[1]]
createDataPartition(training$diagnosis, p = 3/4)
names(prediction   predrf = predict(rf, newdata=testing)
predgbm = predict(gbm, newdata=testing)
predlda = predict(lda, newdata=testing)
stackedpred = predict(stackedmod, newdata=testing))
predrf = predict(rf, newdata=testing)
predgbm = predict(gbm, newdata=testing)
predlda = predict(lda, newdata=testing)
stackedpred = predict(stackedmod, newdata=testing)
predictions = data.frame(predrf, predgbm, predlda, stackedpred)
accuracy = function(x, answers=testing$diagnosis) {
sum(x == answers) / length(answers)
}
accuracies = with(predictions, c(rf=accuracy(predrf), gbm=accuracy(predgbm), lda=accuracy(predlda),
stacked=accuracy(stackedpred)))
accuracies
source('~/Git/Kaggle_Titanic/titanic.R')
setwd("C:\\Users\\K-Dawg\\Documents\\Git\\Kaggle_Titanic")
source('~/Git/Kaggle_Titanic/titanic.R')
aic
sum(tree == testing$Survived) / length(testing$Survived) * 100
sum(rf == testing$Survived) / length(testing$Survived) * 100
sum(gbm == testing$Survived) / length(testing$Survived) * 100
sum(svm == testing$Survived) / length(testing$Survived) * 100
training
